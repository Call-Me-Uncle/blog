### 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？
* 分两章来讲解，争取吃透复杂度
* 复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半
* 为什么需要复杂度分析
  * 粗略的估计算法的执行效率
* 分为时间、空间复杂度  
#### 本章主要讨论时间复杂度，务必拿下
##### 什么是时间复杂度
* cpu的角度来看，每行代码都执行着类似的操作， 读数据-运算-写数据。每行执行时间大致看做一致，可以推导出
所有代码的执行时间T(n)与每行代码的执行次数 n 成正比

规律总结成公式：
```
T(n) = O(f(n));
```

T(n)表示代码执行时间， n 表示数据规模的大小，f(n)表示**每行代码执行的次数总和**。O 表示 ，代码的执行时间 T(n) 与代码的 f(n) 表达式成正比。

* 这就是大O 时间复杂度表示法，用来表示 代码执行时间随数据规模增长的变化趋势，也叫 渐进时间复杂度

#### 时间复杂度分析方法
1. 只关注循环次数最多的一段代码
2. 总时间复杂度等于量级最大的那段代码的时间复杂度
3. 乘法： 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

#### 几种常见时间复杂度实例分析
常见复杂度量级（按量级递增）
* 常量阶 O(1)
* 对数阶 O(logn)
* 线性阶 O(n)
* 线性对数阶 O(nlog(n))
* 平方阶 O(n^2)、立方阶 O(n^3)...k次方阶O(n^k)
* 指数阶 O(2^n)
* 阶乘阶 O(n!)

粗略分为两类：多项式量级和非多项式量级。
非多项式量级只有两个： O(2^n) 和 O(n!)。 把这类算法问题，叫做NP(非确定多项式)问题。当n增大，执行时间急剧增大，是非常低效的算法。

##### O(logn)、O(nlogn)
```
 i=1;
 while (i <= n)  {
   i = i * 2;
 }
```
* 2^x = n, x = log2n, 所以时间复杂度为 O(log2n)，忽略常量 即 O(logn).
##### O(m+n)、O(m*n) ,由两个数据决定
```

int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```

#### 空间复杂度
* 全程： 渐进空间复杂度
* 表示算法的存储空间与数据规模之间的增长关系
* 举例： 第三行，申请了一个大小为n的int类型数组，所以整段代码，空间复杂度为 O(n)
* 常见的空间复杂度： O(1) 、 O(n) 、O(n^2), 像 O(logn)、 O(nlogn)这样的对数阶复杂度平时都用不到。而且空间复杂度分析比时间复杂度简单很对，所以空间复杂度，掌握上述内容就足够了

